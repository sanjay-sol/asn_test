"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AztecClientBackend = exports.UltraHonkBackend = exports.UltraPlonkBackend = exports.AztecClientBackendError = void 0;
const index_js_1 = require("./index.js");
const raw_buffer_js_1 = require("../types/raw_buffer.js");
const fflate_1 = require("fflate");
const index_js_2 = require("../proof/index.js");
class AztecClientBackendError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.AztecClientBackendError = AztecClientBackendError;
class UltraPlonkBackend {
    constructor(acirBytecode, backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.backendOptions);
            const honkRecursion = false;
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const [_total, subgroupSize] = await api.acirGetCircuitSizes(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
            await api.initSRSForCircuitSize(subgroupSize);
            this.acirComposer = await api.acirNewAcirComposer(subgroupSize);
            await api.acirInitProvingKey(this.acirComposer, this.acirUncompressedBytecode, this.circuitOptions.recursive);
            this.api = api;
        }
    }
    /** @description Generates a proof */
    async generateProof(compressedWitness) {
        await this.instantiate();
        const proofWithPublicInputs = await this.api.acirCreateProof(this.acirComposer, this.acirUncompressedBytecode, this.circuitOptions.recursive, (0, fflate_1.decompressSync)(compressedWitness));
        // This is the number of bytes in a UltraPlonk proof
        // minus the public inputs.
        const numBytesInProofWithoutPublicInputs = 2144;
        const splitIndex = proofWithPublicInputs.length - numBytesInProofWithoutPublicInputs;
        const publicInputsConcatenated = proofWithPublicInputs.slice(0, splitIndex);
        const proof = proofWithPublicInputs.slice(splitIndex);
        const publicInputs = (0, index_js_2.deflattenFields)(publicInputsConcatenated);
        return { proof, publicInputs };
    }
    /**
     * Generates artifacts that will be passed to a circuit that will verify this proof.
     *
     * Instead of passing the proof and verification key as a byte array, we pass them
     * as fields which makes it cheaper to verify in a circuit.
     *
     * The proof that is passed here will have been created by passing the `recursive`
     * parameter to a backend.
     *
     * The number of public inputs denotes how many public inputs are in the inner proof.
     *
     * @example
     * ```typescript
     * const artifacts = await backend.generateRecursiveProofArtifacts(proof, numOfPublicInputs);
     * ```
     */
    async generateRecursiveProofArtifacts(proofData, numOfPublicInputs = 0) {
        await this.instantiate();
        const proof = (0, index_js_2.reconstructUltraPlonkProof)(proofData);
        const proofAsFields = (await this.api.acirSerializeProofIntoFields(this.acirComposer, proof, numOfPublicInputs)).slice(numOfPublicInputs);
        // TODO: perhaps we should put this in the init function. Need to benchmark
        // TODO how long it takes.
        await this.api.acirInitVerificationKey(this.acirComposer);
        // Note: If you don't init verification key, `acirSerializeVerificationKeyIntoFields`` will just hang on serialization
        const vk = await this.api.acirSerializeVerificationKeyIntoFields(this.acirComposer);
        return {
            proofAsFields: proofAsFields.map(p => p.toString()),
            vkAsFields: vk[0].map(vk => vk.toString()),
            vkHash: vk[1].toString(),
        };
    }
    /** @description Verifies a proof */
    async verifyProof(proofData) {
        await this.instantiate();
        await this.api.acirInitVerificationKey(this.acirComposer);
        const proof = (0, index_js_2.reconstructUltraPlonkProof)(proofData);
        return await this.api.acirVerifyProof(this.acirComposer, proof);
    }
    /** @description Returns the verification key */
    async getVerificationKey() {
        await this.instantiate();
        await this.api.acirInitVerificationKey(this.acirComposer);
        return await this.api.acirGetVerificationKey(this.acirComposer);
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier() {
        await this.instantiate();
        await this.api.acirInitVerificationKey(this.acirComposer);
        return await this.api.acirGetSolidityVerifier(this.acirComposer);
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.UltraPlonkBackend = UltraPlonkBackend;
class UltraHonkBackend {
    constructor(acirBytecode, backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.backendOptions);
            const honkRecursion = true;
            await api.acirInitSRS(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
            // We don't init a proving key here in the Honk API
            // await api.acirInitProvingKey(this.acirComposer, this.acirUncompressedBytecode);
            this.api = api;
        }
    }
    async generateProof(compressedWitness, options) {
        await this.instantiate();
        const proveUltraHonk = options?.keccak
            ? this.api.acirProveUltraKeccakHonk.bind(this.api)
            : this.api.acirProveUltraHonk.bind(this.api);
        const proofWithPublicInputs = await proveUltraHonk(this.acirUncompressedBytecode, (0, fflate_1.decompressSync)(compressedWitness));
        // Write VK to get the number of public inputs
        const writeVKUltraHonk = options?.keccak
            ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api)
            : this.api.acirWriteVkUltraHonk.bind(this.api);
        const vk = await writeVKUltraHonk(this.acirUncompressedBytecode);
        const vkAsFields = await this.api.acirVkAsFieldsUltraHonk(new raw_buffer_js_1.RawBuffer(vk));
        // Item at index 1 in VK is the number of public inputs
        const publicInputsSizeIndex = 1; // index into VK for numPublicInputs
        const numPublicInputs = Number(vkAsFields[publicInputsSizeIndex].toString()) - index_js_2.AGGREGATION_OBJECT_LENGTH;
        const { proof, publicInputs: publicInputsBytes } = (0, index_js_2.splitHonkProof)(proofWithPublicInputs, numPublicInputs);
        const publicInputs = (0, index_js_2.deflattenFields)(publicInputsBytes);
        return { proof, publicInputs };
    }
    async verifyProof(proofData, options) {
        await this.instantiate();
        const proof = (0, index_js_2.reconstructHonkProof)((0, index_js_2.flattenFieldsAsArray)(proofData.publicInputs), proofData.proof);
        const writeVkUltraHonk = options?.keccak
            ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api)
            : this.api.acirWriteVkUltraHonk.bind(this.api);
        const verifyUltraHonk = options?.keccak
            ? this.api.acirVerifyUltraKeccakHonk.bind(this.api)
            : this.api.acirVerifyUltraHonk.bind(this.api);
        const vkBuf = await writeVkUltraHonk(this.acirUncompressedBytecode);
        return await verifyUltraHonk(proof, new raw_buffer_js_1.RawBuffer(vkBuf));
    }
    async getVerificationKey(options) {
        await this.instantiate();
        return options?.keccak
            ? await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode)
            : await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode);
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier(vk) {
        await this.instantiate();
        const vkBuf = vk ?? (await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode));
        return await this.api.acirHonkSolidityVerifier(this.acirUncompressedBytecode, new raw_buffer_js_1.RawBuffer(vkBuf));
    }
    // TODO(https://github.com/noir-lang/noir/issues/5661): Update this to handle Honk recursive aggregation in the browser once it is ready in the backend itself
    async generateRecursiveProofArtifacts(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _proof, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _numOfPublicInputs) {
        await this.instantiate();
        // TODO(https://github.com/noir-lang/noir/issues/5661): This needs to be updated to handle recursive aggregation.
        // There is still a proofAsFields method but we could consider getting rid of it as the proof itself
        // is a list of field elements.
        // UltraHonk also does not have public inputs directly prepended to the proof and they are still instead
        // inserted at an offset.
        // const proof = reconstructProofWithPublicInputs(proofData);
        // const proofAsFields = (await this.api.acirProofAsFieldsUltraHonk(proof)).slice(numOfPublicInputs);
        // TODO: perhaps we should put this in the init function. Need to benchmark
        // TODO how long it takes.
        const vkBuf = await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode);
        const vk = await this.api.acirVkAsFieldsUltraHonk(vkBuf);
        return {
            // TODO(https://github.com/noir-lang/noir/issues/5661)
            proofAsFields: [],
            vkAsFields: vk.map(vk => vk.toString()),
            // We use an empty string for the vk hash here as it is unneeded as part of the recursive artifacts
            // The user can be expected to hash the vk inside their circuit to check whether the vk is the circuit
            // they expect
            vkHash: '',
        };
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.UltraHonkBackend = UltraHonkBackend;
class AztecClientBackend {
    constructor(acirMsgpack, options = { threads: 1 }) {
        this.acirMsgpack = acirMsgpack;
        this.options = options;
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.options);
            await api.initSRSClientIVC();
            this.api = api;
        }
    }
    async prove(witnessMsgpack) {
        await this.instantiate();
        const proofAndVk = await this.api.acirProveAztecClient(this.acirMsgpack, witnessMsgpack);
        const [proof, vk] = proofAndVk;
        if (!(await this.verify(proof, vk))) {
            throw new AztecClientBackendError('Failed to verify the private (ClientIVC) transaction proof!');
        }
        return proofAndVk;
    }
    async verify(proof, vk) {
        await this.instantiate();
        return this.api.acirVerifyAztecClient(proof, vk);
    }
    async proveAndVerify(witnessMsgpack) {
        await this.instantiate();
        return this.api.acirProveAndVerifyAztecClient(this.acirMsgpack, witnessMsgpack);
    }
    async gates() {
        // call function on API
        await this.instantiate();
        return this.api.acirGatesAztecClient(this.acirMsgpack);
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.AztecClientBackend = AztecClientBackend;
// Converts bytecode from a base64 string to a Uint8Array
function acirToUint8Array(base64EncodedBytecode) {
    const compressedByteCode = base64Decode(base64EncodedBytecode);
    return (0, fflate_1.decompressSync)(compressedByteCode);
}
// Since this is a simple function, we can use feature detection to
// see if we are in the nodeJs environment or the browser environment.
function base64Decode(input) {
    if (typeof Buffer !== 'undefined') {
        // Node.js environment
        const b = Buffer.from(input, 'base64');
        return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    }
    else if (typeof atob === 'function') {
        // Browser environment
        return Uint8Array.from(atob(input), c => c.charCodeAt(0));
    }
    else {
        throw new Error('No implementation found for base64 decoding.');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmcvYmFja2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBMEU7QUFDMUUsMERBQW1EO0FBQ25ELG1DQUFrRDtBQUNsRCxnREFRMkI7QUFFM0IsTUFBYSx1QkFBd0IsU0FBUSxLQUFLO0lBQ2hELFlBQVksT0FBZTtRQUN6QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakIsQ0FBQztDQUNGO0FBSkQsMERBSUM7QUFFRCxNQUFhLGlCQUFpQjtJQVk1QixZQUNFLFlBQW9CLEVBQ1YsaUJBQWlDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUMvQyxpQkFBaUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFO1FBRHJELG1CQUFjLEdBQWQsY0FBYyxDQUFpQztRQUMvQyxtQkFBYyxHQUFkLGNBQWMsQ0FBdUM7UUFFL0QsSUFBSSxDQUFDLHdCQUF3QixHQUFHLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxjQUFjO0lBQ2QsS0FBSyxDQUFDLFdBQVc7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxHQUFHLEdBQUcsTUFBTSx1QkFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFFeEQsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDO1lBQzVCLDZEQUE2RDtZQUM3RCxNQUFNLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLG1CQUFtQixDQUMxRCxJQUFJLENBQUMsd0JBQXdCLEVBQzdCLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUM3QixhQUFhLENBQ2QsQ0FBQztZQUVGLE1BQU0sR0FBRyxDQUFDLHFCQUFxQixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxHQUFHLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDaEUsTUFBTSxHQUFHLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5RyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQztJQUVELHFDQUFxQztJQUNyQyxLQUFLLENBQUMsYUFBYSxDQUFDLGlCQUE2QjtRQUMvQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixNQUFNLHFCQUFxQixHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQzFELElBQUksQ0FBQyxZQUFZLEVBQ2pCLElBQUksQ0FBQyx3QkFBd0IsRUFDN0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQzdCLElBQUEsdUJBQU0sRUFBQyxpQkFBaUIsQ0FBQyxDQUMxQixDQUFDO1FBRUYsb0RBQW9EO1FBQ3BELDJCQUEyQjtRQUMzQixNQUFNLGtDQUFrQyxHQUFHLElBQUksQ0FBQztRQUVoRCxNQUFNLFVBQVUsR0FBRyxxQkFBcUIsQ0FBQyxNQUFNLEdBQUcsa0NBQWtDLENBQUM7UUFFckYsTUFBTSx3QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzVFLE1BQU0sS0FBSyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN0RCxNQUFNLFlBQVksR0FBRyxJQUFBLDBCQUFlLEVBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUUvRCxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSCxLQUFLLENBQUMsK0JBQStCLENBQ25DLFNBQW9CLEVBQ3BCLGlCQUFpQixHQUFHLENBQUM7UUFNckIsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFekIsTUFBTSxLQUFLLEdBQUcsSUFBQSxxQ0FBMEIsRUFBQyxTQUFTLENBQUMsQ0FBQztRQUNwRCxNQUFNLGFBQWEsR0FBRyxDQUNwQixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FDekYsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUUzQiwyRUFBMkU7UUFDM0UsMEJBQTBCO1FBQzFCLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFMUQsc0hBQXNIO1FBQ3RILE1BQU0sRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxzQ0FBc0MsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFcEYsT0FBTztZQUNMLGFBQWEsRUFBRSxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ25ELFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQzFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFO1NBQ3pCLENBQUM7SUFDSixDQUFDO0lBRUQsb0NBQW9DO0lBQ3BDLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBb0I7UUFDcEMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUMxRCxNQUFNLEtBQUssR0FBRyxJQUFBLHFDQUEwQixFQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BELE9BQU8sTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRCxnREFBZ0Q7SUFDaEQsS0FBSyxDQUFDLGtCQUFrQjtRQUN0QixNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzFELE9BQU8sTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQsK0NBQStDO0lBQy9DLEtBQUssQ0FBQyxtQkFBbUI7UUFDdkIsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUMxRCxPQUFPLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVELEtBQUssQ0FBQyxPQUFPO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNkLE9BQU87UUFDVCxDQUFDO1FBQ0QsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzNCLENBQUM7Q0FDRjtBQXhJRCw4Q0F3SUM7QUFhRCxNQUFhLGdCQUFnQjtJQVMzQixZQUNFLFlBQW9CLEVBQ1YsaUJBQWlDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUMvQyxpQkFBaUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFO1FBRHJELG1CQUFjLEdBQWQsY0FBYyxDQUFpQztRQUMvQyxtQkFBYyxHQUFkLGNBQWMsQ0FBdUM7UUFFL0QsSUFBSSxDQUFDLHdCQUF3QixHQUFHLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFDRCxjQUFjO0lBQ2QsS0FBSyxDQUFDLFdBQVc7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxHQUFHLEdBQUcsTUFBTSx1QkFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDeEQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDO1lBQzNCLE1BQU0sR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFbkcsbURBQW1EO1lBQ25ELGtGQUFrRjtZQUNsRixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUssQ0FBQyxhQUFhLENBQUMsaUJBQTZCLEVBQUUsT0FBaUM7UUFDbEYsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFekIsTUFBTSxjQUFjLEdBQUcsT0FBTyxFQUFFLE1BQU07WUFDcEMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDbEQsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUUvQyxNQUFNLHFCQUFxQixHQUFHLE1BQU0sY0FBYyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxJQUFBLHVCQUFNLEVBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1FBRTdHLDhDQUE4QztRQUM5QyxNQUFNLGdCQUFnQixHQUFHLE9BQU8sRUFBRSxNQUFNO1lBQ3RDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ3BELENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFakQsTUFBTSxFQUFFLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUNqRSxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsSUFBSSx5QkFBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFN0UsdURBQXVEO1FBQ3ZELE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxDQUFDLENBQUMsb0NBQW9DO1FBQ3JFLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLG9DQUF5QixDQUFDO1FBRXpHLE1BQU0sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsSUFBQSx5QkFBYyxFQUFDLHFCQUFxQixFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBQzFHLE1BQU0sWUFBWSxHQUFHLElBQUEsMEJBQWUsRUFBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRXhELE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVELEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBb0IsRUFBRSxPQUFpQztRQUN2RSxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUV6QixNQUFNLEtBQUssR0FBRyxJQUFBLCtCQUFvQixFQUFDLElBQUEsK0JBQW9CLEVBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsRyxNQUFNLGdCQUFnQixHQUFHLE9BQU8sRUFBRSxNQUFNO1lBQ3RDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ3BELENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakQsTUFBTSxlQUFlLEdBQUcsT0FBTyxFQUFFLE1BQU07WUFDckMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDbkQsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVoRCxNQUFNLEtBQUssR0FBRyxNQUFNLGdCQUFnQixDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBQ3BFLE9BQU8sTUFBTSxlQUFlLENBQUMsS0FBSyxFQUFFLElBQUkseUJBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRCxLQUFLLENBQUMsa0JBQWtCLENBQUMsT0FBaUM7UUFDeEQsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsT0FBTyxPQUFPLEVBQUUsTUFBTTtZQUNwQixDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQztZQUMxRSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCwrQ0FBK0M7SUFDL0MsS0FBSyxDQUFDLG1CQUFtQixDQUFDLEVBQWU7UUFDdkMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsTUFBTSxLQUFLLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7UUFDL0YsT0FBTyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUkseUJBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3RHLENBQUM7SUFFRCw4SkFBOEo7SUFDOUosS0FBSyxDQUFDLCtCQUErQjtJQUNuQyw2REFBNkQ7SUFDN0QsTUFBa0I7SUFDbEIsNkRBQTZEO0lBQzdELGtCQUEwQjtRQUUxQixNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixpSEFBaUg7UUFDakgsb0dBQW9HO1FBQ3BHLCtCQUErQjtRQUMvQix3R0FBd0c7UUFDeEcseUJBQXlCO1FBQ3pCLDZEQUE2RDtRQUM3RCxxR0FBcUc7UUFFckcsMkVBQTJFO1FBQzNFLDBCQUEwQjtRQUMxQixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFDakYsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXpELE9BQU87WUFDTCxzREFBc0Q7WUFDdEQsYUFBYSxFQUFFLEVBQUU7WUFDakIsVUFBVSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDdkMsbUdBQW1HO1lBQ25HLHNHQUFzRztZQUN0RyxjQUFjO1lBQ2QsTUFBTSxFQUFFLEVBQUU7U0FDWCxDQUFDO0lBQ0osQ0FBQztJQUVELEtBQUssQ0FBQyxPQUFPO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNkLE9BQU87UUFDVCxDQUFDO1FBQ0QsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzNCLENBQUM7Q0FDRjtBQTVIRCw0Q0E0SEM7QUFFRCxNQUFhLGtCQUFrQjtJQVE3QixZQUFzQixXQUF5QixFQUFZLFVBQTBCLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRTtRQUE3RSxnQkFBVyxHQUFYLFdBQVcsQ0FBYztRQUFZLFlBQU8sR0FBUCxPQUFPLENBQWlDO0lBQUcsQ0FBQztJQUV2RyxjQUFjO0lBQ2QsS0FBSyxDQUFDLFdBQVc7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsTUFBTSxHQUFHLEdBQUcsTUFBTSx1QkFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDakQsTUFBTSxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUM3QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUssQ0FBQyxLQUFLLENBQUMsY0FBNEI7UUFDdEMsTUFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDekIsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDekYsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7UUFDL0IsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDcEMsTUFBTSxJQUFJLHVCQUF1QixDQUFDLDZEQUE2RCxDQUFDLENBQUM7UUFDbkcsQ0FBQztRQUNELE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQWlCLEVBQUUsRUFBYztRQUM1QyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRCxLQUFLLENBQUMsY0FBYyxDQUFDLGNBQTRCO1FBQy9DLE1BQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBSztRQUNULHVCQUF1QjtRQUN2QixNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxLQUFLLENBQUMsT0FBTztRQUNYLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDZCxPQUFPO1FBQ1QsQ0FBQztRQUNELE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUFuREQsZ0RBbURDO0FBRUQseURBQXlEO0FBQ3pELFNBQVMsZ0JBQWdCLENBQUMscUJBQTZCO0lBQ3JELE1BQU0sa0JBQWtCLEdBQUcsWUFBWSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDL0QsT0FBTyxJQUFBLHVCQUFNLEVBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNwQyxDQUFDO0FBRUQsbUVBQW1FO0FBQ25FLHNFQUFzRTtBQUN0RSxTQUFTLFlBQVksQ0FBQyxLQUFhO0lBQ2pDLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxFQUFFLENBQUM7UUFDbEMsc0JBQXNCO1FBQ3RCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5RCxDQUFDO1NBQU0sSUFBSSxPQUFPLElBQUksS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUN0QyxzQkFBc0I7UUFDdEIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RCxDQUFDO1NBQU0sQ0FBQztRQUNOLE1BQU0sSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0FBQ0gsQ0FBQyJ9