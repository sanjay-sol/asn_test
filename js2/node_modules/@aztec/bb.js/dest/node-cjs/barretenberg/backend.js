"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AztecClientBackend = exports.UltraHonkBackend = exports.AztecClientBackendError = void 0;
const index_js_1 = require("./index.js");
const raw_buffer_js_1 = require("../types/raw_buffer.js");
const index_js_2 = require("../proof/index.js");
const pack_1 = require("msgpackr/pack");
const pako_1 = require("pako");
class AztecClientBackendError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.AztecClientBackendError = AztecClientBackendError;
// Utility for parsing gate counts from buffer
// TODO: Where should this logic live? Should go away with move to msgpack.
function parseBigEndianU32Array(buffer) {
    const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    let offset = 0;
    const count = buffer.byteLength >>> 2; // default is entire buffer length / 4
    const out = new Array(count);
    for (let i = 0; i < count; i++) {
        out[i] = dv.getUint32(offset, false);
        offset += 4;
    }
    return out;
}
class UltraHonkBackend {
    constructor(acirBytecode, backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.backendOptions);
            const honkRecursion = true;
            await api.acirInitSRS(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
            // We don't init a proving key here in the Honk API
            // await api.acirInitProvingKey(this.acirComposer, this.acirUncompressedBytecode);
            this.api = api;
        }
    }
    async generateProof(compressedWitness, options) {
        await this.instantiate();
        // Write VK to get the number of public inputs
        const writeVKUltraHonk = options?.keccak
            ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api)
            : options?.keccakZK
                ? this.api.acirWriteVkUltraKeccakZkHonk.bind(this.api)
                : options?.starknet
                    ? this.api.acirWriteVkUltraStarknetHonk.bind(this.api)
                    : options?.starknetZK
                        ? this.api.acirWriteVkUltraStarknetZkHonk.bind(this.api)
                        : this.api.acirWriteVkUltraHonk.bind(this.api);
        const vkBuf = await writeVKUltraHonk(this.acirUncompressedBytecode);
        const vkAsFields = await this.api.acirVkAsFieldsUltraHonk(new raw_buffer_js_1.RawBuffer(vkBuf));
        const proveUltraHonk = options?.keccak
            ? this.api.acirProveUltraKeccakHonk.bind(this.api)
            : options?.keccakZK
                ? this.api.acirProveUltraKeccakZkHonk.bind(this.api)
                : options?.starknet
                    ? this.api.acirProveUltraStarknetHonk.bind(this.api)
                    : options?.starknetZK
                        ? this.api.acirProveUltraStarknetZkHonk.bind(this.api)
                        : this.api.acirProveUltraHonk.bind(this.api);
        const proofWithPublicInputs = await proveUltraHonk(this.acirUncompressedBytecode, (0, pako_1.ungzip)(compressedWitness), new raw_buffer_js_1.RawBuffer(vkBuf));
        // Item at index 1 in VK is the number of public inputs
        const publicInputsSizeIndex = 1; // index into VK for numPublicInputs
        const numPublicInputs = Number(vkAsFields[publicInputsSizeIndex].toString()) - index_js_2.PAIRING_POINTS_SIZE;
        const { proof, publicInputs: publicInputsBytes } = (0, index_js_2.splitHonkProof)(proofWithPublicInputs, numPublicInputs);
        const publicInputs = (0, index_js_2.deflattenFields)(publicInputsBytes);
        return { proof, publicInputs };
    }
    async verifyProof(proofData, options) {
        await this.instantiate();
        const proof = (0, index_js_2.reconstructHonkProof)((0, index_js_2.flattenFieldsAsArray)(proofData.publicInputs), proofData.proof);
        const writeVkUltraHonk = options?.keccak
            ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api)
            : options?.keccakZK
                ? this.api.acirWriteVkUltraKeccakZkHonk.bind(this.api)
                : options?.starknet
                    ? this.api.acirWriteVkUltraStarknetHonk.bind(this.api)
                    : options?.starknetZK
                        ? this.api.acirWriteVkUltraStarknetZkHonk.bind(this.api)
                        : this.api.acirWriteVkUltraHonk.bind(this.api);
        const verifyUltraHonk = options?.keccak
            ? this.api.acirVerifyUltraKeccakHonk.bind(this.api)
            : options?.keccakZK
                ? this.api.acirVerifyUltraKeccakZkHonk.bind(this.api)
                : options?.starknet
                    ? this.api.acirVerifyUltraStarknetHonk.bind(this.api)
                    : options?.starknetZK
                        ? this.api.acirVerifyUltraStarknetZkHonk.bind(this.api)
                        : this.api.acirVerifyUltraHonk.bind(this.api);
        const vkBuf = await writeVkUltraHonk(this.acirUncompressedBytecode);
        return await verifyUltraHonk(proof, new raw_buffer_js_1.RawBuffer(vkBuf));
    }
    async getVerificationKey(options) {
        await this.instantiate();
        return options?.keccak
            ? await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode)
            : options?.keccakZK
                ? await this.api.acirWriteVkUltraKeccakZkHonk(this.acirUncompressedBytecode)
                : options?.starknet
                    ? await this.api.acirWriteVkUltraStarknetHonk(this.acirUncompressedBytecode)
                    : options?.starknetZK
                        ? await this.api.acirWriteVkUltraStarknetZkHonk(this.acirUncompressedBytecode)
                        : await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode);
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier(vk) {
        await this.instantiate();
        const vkBuf = vk ?? (await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode));
        return await this.api.acirHonkSolidityVerifier(this.acirUncompressedBytecode, new raw_buffer_js_1.RawBuffer(vkBuf));
    }
    // TODO(https://github.com/noir-lang/noir/issues/5661): Update this to handle Honk recursive aggregation in the browser once it is ready in the backend itself
    async generateRecursiveProofArtifacts(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _proof, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _numOfPublicInputs) {
        await this.instantiate();
        // TODO(https://github.com/noir-lang/noir/issues/5661): This needs to be updated to handle recursive aggregation.
        // There is still a proofAsFields method but we could consider getting rid of it as the proof itself
        // is a list of field elements.
        // UltraHonk also does not have public inputs directly prepended to the proof and they are still instead
        // inserted at an offset.
        // const proof = reconstructProofWithPublicInputs(proofData);
        // const proofAsFields = (await this.api.acirProofAsFieldsUltraHonk(proof)).slice(numOfPublicInputs);
        // TODO: perhaps we should put this in the init function. Need to benchmark
        // TODO how long it takes.
        const vkBuf = await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode);
        const vk = await this.api.acirVkAsFieldsUltraHonk(vkBuf);
        return {
            // TODO(https://github.com/noir-lang/noir/issues/5661)
            proofAsFields: [],
            vkAsFields: vk.map(vk => vk.toString()),
            // We use an empty string for the vk hash here as it is unneeded as part of the recursive artifacts
            // The user can be expected to hash the vk inside their circuit to check whether the vk is the circuit
            // they expect
            vkHash: '',
        };
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.UltraHonkBackend = UltraHonkBackend;
function serializeAztecClientExecutionSteps(acirBuf, witnessBuf, vksBuf) {
    const steps = [];
    for (let i = 0; i < acirBuf.length; i++) {
        const bytecode = acirBuf[i];
        // Witnesses are not provided at all for gates info.
        const witness = witnessBuf[i] || Buffer.from([]);
        // VKs are optional for proving (deprecated feature) or not provided at all for gates info.
        const vk = vksBuf[i] || Buffer.from([]);
        const functionName = `unknown_wasm_${i}`;
        steps.push({
            bytecode,
            witness,
            vk,
            functionName,
        });
    }
    return new pack_1.Encoder({ useRecords: false }).pack(steps);
}
class AztecClientBackend {
    constructor(acirBuf, options = { threads: 1 }) {
        this.acirBuf = acirBuf;
        this.options = options;
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await index_js_1.Barretenberg.new(this.options);
            await api.initSRSClientIVC();
            this.api = api;
        }
    }
    async prove(witnessBuf, vksBuf = []) {
        if (vksBuf.length !== 0 && this.acirBuf.length !== witnessBuf.length) {
            throw new AztecClientBackendError('Witness and bytecodes must have the same stack depth!');
        }
        if (vksBuf.length !== 0 && vksBuf.length !== witnessBuf.length) {
            // NOTE: we allow 0 as an explicit 'I have no VKs'. This is a deprecated feature.
            throw new AztecClientBackendError('Witness and VKs must have the same stack depth!');
        }
        await this.instantiate();
        const ivcInputsBuf = serializeAztecClientExecutionSteps(this.acirBuf, witnessBuf, vksBuf);
        const proofAndVk = await this.api.acirProveAztecClient(ivcInputsBuf);
        const [proof, vk] = proofAndVk;
        if (!(await this.verify(proof, vk))) {
            throw new AztecClientBackendError('Failed to verify the private (ClientIVC) transaction proof!');
        }
        return proofAndVk;
    }
    async verify(proof, vk) {
        await this.instantiate();
        return this.api.acirVerifyAztecClient(proof, vk);
    }
    async gates() {
        // call function on API
        await this.instantiate();
        const ivcInputsBuf = serializeAztecClientExecutionSteps(this.acirBuf, [], []);
        const resultBuffer = await this.api.acirGatesAztecClient(ivcInputsBuf);
        return parseBigEndianU32Array(resultBuffer);
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
exports.AztecClientBackend = AztecClientBackend;
// Converts bytecode from a base64 string to a Uint8Array
function acirToUint8Array(base64EncodedBytecode) {
    const compressedByteCode = base64Decode(base64EncodedBytecode);
    return (0, pako_1.ungzip)(compressedByteCode);
}
// Since this is a simple function, we can use feature detection to
// see if we are in the nodeJs environment or the browser environment.
function base64Decode(input) {
    if (typeof Buffer !== 'undefined') {
        // Node.js environment
        const b = Buffer.from(input, 'base64');
        return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    }
    else if (typeof atob === 'function') {
        // Browser environment
        return Uint8Array.from(atob(input), c => c.charCodeAt(0));
    }
    else {
        throw new Error('No implementation found for base64 decoding.');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmcvYmFja2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx5Q0FBMEU7QUFDMUUsMERBQW1EO0FBQ25ELGdEQU8yQjtBQUMzQix3Q0FBd0M7QUFDeEMsK0JBQThCO0FBRTlCLE1BQWEsdUJBQXdCLFNBQVEsS0FBSztJQUNoRCxZQUFZLE9BQWU7UUFDekIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pCLENBQUM7Q0FDRjtBQUpELDBEQUlDO0FBRUQsOENBQThDO0FBQzlDLDJFQUEyRTtBQUMzRSxTQUFTLHNCQUFzQixDQUFDLE1BQWtCO0lBQ2hELE1BQU0sRUFBRSxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFN0UsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFVBQVUsS0FBSyxDQUFDLENBQUMsQ0FBQyxzQ0FBc0M7SUFFN0UsTUFBTSxHQUFHLEdBQWEsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQy9CLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNyQyxNQUFNLElBQUksQ0FBQyxDQUFDO0lBQ2QsQ0FBQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQTRCRCxNQUFhLGdCQUFnQjtJQVMzQixZQUNFLFlBQW9CLEVBQ1YsaUJBQWlDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUMvQyxpQkFBaUMsRUFBRSxT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